{
  "version": 3,
  "sources": ["../src/interplay.ts"],
  "sourcesContent": ["/*!\n * @license zig-js-interplay\n *\n * Copyright (c) Daniel Oltmanns.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntype InterplayTypeHalf = bigint;\ntype InterplayType = [InterplayTypeHalf, InterplayTypeHalf];\n\nexport default class InterplayInstance {\n    /**\n     * Hold the exports of the WASM instance. This is the core of this wrapper functionality.\n     */\n    #wasm: WebAssembly.Exports = undefined;\n\n    /**\n     * This will be overwritten by an exported global which indicates the protected memory which\n     * should not be freed.\n     */\n    #wasmMemoryDataPtr: number = 0;\n\n    /**\n     * Central Text Decoder instance for converting bytes to string.\n     */\n    #textDecoder = new TextDecoder();\n\n    /**\n     * Central Text Encoder instance for converting string to bytes.\n     */\n    #textEncoder = new TextEncoder();\n\n    /**\n     * Table to assign a number to a JavaScript function in order to remember\n     * it by an unique id and being able to call it again if necessary.\n     */\n    #functionTable: {[key: number]: Function} = {};\n\n    /**\n     * There will be functions assigned by name from the WASM exports and made accessible directly.\n     */\n    [key: string]: Function;\n\n    /**\n     * Initialize a new Wrapper instance from an url which is loaded in async via fetch.\n     * \n     * @param wasmUrl URL to given wasm file that should be loaded\n     * @returns new instance of the ZigWASMWrapper for this wasm file\n     */\n    static async initializeFromUrl(wasmUrl: URL): Promise<InterplayInstance> {\n        const rawWasm = await fetch(wasmUrl).then(resp => resp.arrayBuffer());\n\n        return this.initialize(rawWasm);\n    }\n\n    /**\n     * Initialize a new Wrapper directly from the raw WASM bytes.\n     * \n     * @param rawModule raw bytes of the wasm module to initialize\n     * @returns new instance of the ZigWASMWrapper for this wasm file\n     */\n    static async initialize(rawModule: BufferSource): Promise<InterplayInstance> {\n        const inst = new this();\n\n        const obj = await WebAssembly.instantiate(rawModule, {\n            js: {\n                log: (arg: InterplayTypeHalf, arg2: InterplayTypeHalf) => {\n                    let message = inst.#decodeInterplayType([arg, arg2]).value;\n                    console.log(message);\n                },\n                call: (func: InterplayTypeHalf, func2: InterplayTypeHalf, args: InterplayTypeHalf, args2: InterplayTypeHalf) => {\n                    let f = inst.#decodeInterplayType([func, func2]).value;\n\n                    if(Object.getPrototypeOf(f).origin != 1) {\n                        throw new Error('Function to be executed in JS expected to be of JS origin.');\n                    }\n\n                    let a = inst.#decodeInterplayType([args, args2]).value;\n\n                    return inst.#encodeInterplayType(f(...a));\n                }\n            },\n        })\n\n        inst.#loadWasmObj(obj);\n\n        return inst;\n    }\n\n    constructor() {}\n\n    /**\n     * This function does some initialization for a loaded WASM module and raises the WASM exports to functions directly\n     * accessible from this very class instance via the interplay wrapper.\n     * \n     * @param obj the instantiated WASM source for which this class has been created\n     */\n    #loadWasmObj(obj: WebAssembly.WebAssemblyInstantiatedSource) {\n        console.log(obj)\n\n        this.#wasm = obj.instance.exports;\n\n        this.#wasmMemoryDataPtr = obj.instance['$global0'];\n\n        // Expose the exported custom functions that are not implementation relevant\n        for (let name of Object.keys(this.#wasm).filter(n => !['malloc', 'free', 'memory', 'call'].includes(n))) {\n            // Make sure we only wrap exported functions\n            if(typeof this.#wasm[name] !== 'function') {\n                // TODO: Parse constants as well and expose them via getter methods.\n                console.warn('We currently only make exported functions accessible through the Interplay Wrapper.')\n                continue;\n            }\n\n            this[name] = this.#wrappedCallHandler(name)\n        }\n    }\n\n    /**\n     * This not only returns a wrapped function handler, it also checks of the actual export is even a function that we could\n     * call. This should only be called if the caller is sure, the named export is actually a function.\n     * \n     * @param funcName name of the exported wasm function to wrap\n     * @returns handler function for a wrapped call to the named function\n     */\n    #wrappedCallHandler(funcName: string): Function {\n        const wasmFunc = this.#wasm[funcName];\n\n        // Verify the \n        if(typeof wasmFunc !== 'function') throw new Error('WASM export is not callable!');\n\n        return (...args): any => {\n            return this.#wrappedCall(wasmFunc, ...args)\n        }\n    }\n\n    /**\n     * This function abstracts the complexity of calling a WASM exported function directly with JavaScript values of any kind\n     * without thinking about the Interplay Types. The arguments will be automatically converted and the return will be\n     * parsed. This means, there is no need to think about Interplay Types outside of these wrapped calls.\n     * \n     * It is important to not ate this point, allocated resources for converting JavaScript values to Interplay Types will be\n     * automatically freed after the call to the underlying WASM function finished. Values used within the WASM module after\n     * their use within the function block, should not be done. Instead a full copy of that value is necessary.\n     * \n     * @param func name of the function from the WASM exports\n     * @param args arguments that should be converted to Interplay Types\n     * @returns parsed Interplay Type from the return value of that function\n     */\n    #wrappedCall(func: Function, ...args) {\n        // Encode the arguments to interplay types.\n        const wasmArgs = args.map(a => this.#encodeInterplayType(a))\n\n        // Call the underlying function with a flatten array of the encoded types.\n        // The exported wasm functions only accept direct arguments, no arrays or other types.\n        const r = func(...wasmArgs.flat());\n\n        // Free each previosuly argument if there has been an allocation\n        for(let i = 0; i < wasmArgs.length; i++) {\n            this.#freeEncodedInterplayType(wasmArgs[i]);\n        }\n\n        // Correctly decode thhe optional return of the wasm function\n        const wasmReturn = r ? this.#decodeInterplayType(r).value : undefined;\n\n        // Free the interplay type of the return if present and after decoding\n        if(wasmReturn) {\n            this.#freeEncodedInterplayType(r);\n        }\n\n        // There is no need for the wasm function to return something. So we only decode interplay types if we received\n        // an actual value as a return.\n        return wasmReturn;\n    }\n\n    /**\n     * Each InterplayType in Zig is a packed struct of size u128 of which the first 4bit are its type notation. The\n     * reamaining bits can be used as desired for each type, requireing to parse different sections of different use\n     * and size. This function abstracts this to avoid repeating code but introducing a small performance penalty.\n     * \n     * @param value the raw value of bits from where the section values will be extracted\n     * @param sections the sections in which exact order their values of X bits will be extracted\n     * @returns an object with the section name as key and extracted bits as value\n     */\n    #extractBitSections(value: bigint, sections: Array<[string, number]>)  {\n        const r: {[key: string]: bigint} = {};\n\n        let bits = value;\n        for(const section of sections) {\n            r[section[0]] = BigInt.asUintN(section[1], bits);\n            bits >>= BigInt(section[1]);\n        }\n\n        return r;\n    }\n\n    // TODO: Implement this to avoid weird lines of code for encoding\n    #packBitSections(sections: Array<[string, number, bigint]>): bigint { return 0n }\n\n    /**\n     * Detect the correct InterplayTypeId for any JS value. If the type is not supported, we throw an error.\n     * \n     * @param value the value of which the InterplayTypeId should be detected from\n     * @returns the detected InterplayTypeId\n     */\n    #mapValueToInterplayTypeId(value: any): InterplayTypeId {\n        switch (typeof value) {\n            case 'string':\n                return InterplayTypeId.string;\n            case 'number':\n                return ((value % 1) === 0) ? (value < 0) ? InterplayTypeId.int : InterplayTypeId.uint : InterplayTypeId.float;\n            case 'bigint':\n                return (value < 0n) ? InterplayTypeId.int : InterplayTypeId.uint;\n            case 'boolean':\n                return InterplayTypeId.bool;\n            case 'symbol':\n                throw new Error(`type '${typeof value}' (value '${String(value)}') not implemented`)\n            case 'undefined':\n                return InterplayTypeId.void;\n            case 'object': {\n                if (value instanceof Uint8Array || value instanceof ArrayBuffer) {\n                    return InterplayTypeId.bytes;\n                }\n                if(Array.isArray(value)) {\n                    return InterplayTypeId.array;\n                }\n                return InterplayTypeId.json;\n            }\n            case 'function':\n                return InterplayTypeId.function;\n            default:\n                // NOTE: This is just in case, this should be unreachable\n                throw new Error(`type '${typeof value}' not implemented`)\n        }\n    }\n\n    /**\n     * Decode a given Interplay Type to its JavaScript value. Any allocations done to the interplay type can be freed\n     * after this call, as the return value does not depend on the origin value.\n     * \n     * @param value interplay type to decode\n     * @returns decoded interplay type as javascript value\n     */\n    #decodeInterplayType(value: InterplayType): any {\n        // Merge the interplay type to a single u128 value\n        const ipl = BigInt.asUintN(64, value[0]) | (BigInt.asUintN(64, value[1]) << 64n);\n\n        // Extract type and value sections\n        const { type, details } = this.#extractBitSections(ipl, [\n            ['type', 4],\n            ['details', 124]\n        ]);\n\n        switch (Number(type)) {\n            case InterplayTypeId.void:\n                return { type };\n            case InterplayTypeId.bool:\n                return { type, value: ((details & 0x1n) == 1n) ? true : false };\n            case InterplayTypeId.int:\n                return { type, value: BigInt.asIntN(124, details) };\n            case InterplayTypeId.uint:\n                return { type, value: BigInt.asUintN(124, details) };\n            case InterplayTypeId.float: {\n                // We only care about the first 64bit for the float\n                const rawFloatValue = BigInt.asUintN(64, details);\n\n                // Move the value into a correct representation\n                const tempBuf = new ArrayBuffer(8);\n                const tempBufView = new DataView(tempBuf);\n                tempBufView.setBigUint64(0, rawFloatValue);\n\n                // Return correct float value\n                return { type, value: tempBufView.getFloat64(0) };\n            }\n            case InterplayTypeId.bytes: {\n                const buf = this.#decodeBytesLikeType(details);\n\n                // NOTE: It is important to slice as the buf is only pointing to the raw WASM memory section\n                return { type, value: buf.slice() };\n            }\n            case InterplayTypeId.string: {\n                const buf = this.#decodeBytesLikeType(details);\n                const str = this.#textDecoder.decode(buf);\n\n                return { type, value: str };\n            }\n            case InterplayTypeId.json: {\n                const buf = this.#decodeBytesLikeType(details);\n                const str = this.#textDecoder.decode(buf);\n                const json = JSON.parse(str)\n\n                return { type, value: json };\n            }\n            case InterplayTypeId.function: {\n                // Create a function that behaves just like a JavaScript function\n                const f = function (...args) {\n                    // If the function is of JavaScript origin, we can just call it straight from the function table\n                    if(this.prototype.origin == 1) {\n                        return this.prototype.inst.#functionTable[this.prototype.ptr](args)\n                    } else {\n                        // Else we do a wrapped call to the referenced zig function\n                        return this.prototype.inst.#wrappedCall(this.prototype.inst.#wasm.call, this, args);\n                    }\n                }\n                // Extract pointer and origin of the function\n                const { ptr, origin } = this.#extractBitSections(details, [\n                    ['ptr', 32],\n                    ['origin', 1],\n                ])\n\n                // Store function attributes in prototype so we can recoginize it again\n                f.prototype.ptr = ptr;\n                f.prototype.origin = origin;\n                f.prototype.inst = this;\n\n                // Bind it to itself so we can reference this within the function\n                const boundF = f.bind(f);\n                // Copy over the prototype to the bound function\n                Object.setPrototypeOf(boundF, f.prototype);\n\n                return { type, value: boundF };\n            }\n            case InterplayTypeId.array: {\n                // Extract pointer and number of items of the array\n                const { ptr, len } = this.#extractBitSections(details, [\n                    ['ptr', 32],\n                    ['len', 32],\n                ])\n\n                // View as array of u64, the length is twice as long as the number of items because len * 128bit = len * 2 * 64bit\n                const tempBuf = new BigUint64Array((this.#wasm.memory as unknown as Uint8Array).buffer, Number(ptr), Number(len * 2n));\n\n                const decodedArray = [];\n                for(let i = 0; i < len; i++) {\n                    const iplVariable = Array.from(tempBuf.subarray(i * 2, (i + 1) * 2)) as InterplayType;\n                    const variable = this.#decodeInterplayType(iplVariable);\n\n                    decodedArray.push(variable.value);\n                }\n\n                return { type, value: decodedArray };\n            }\n            default:\n                throw new Error(`Interplay type ${type} is not supported for decoding.`)\n        }\n    }\n\n    /**\n     * Encode a JavaScript value to the corresponding interplay type. This may require allocation in memory in order to\n     * transfer the full value to the WASM environment. There is no automatic free and this needs to be done manually\n     * after the interplay type has been used.\n     * \n     * @param value javascript value to encode\n     * @returns encoded javascript value as interplay type\n     */\n    #encodeInterplayType(value: any): InterplayType {\n        // Detect interplay type for the value so we can continue to encode it\n        const iplType = this.#mapValueToInterplayTypeId(value);\n        // Temporary placeholder for the value within the interplay type\n        let iplValue: bigint = 0n;\n\n        switch (iplType) {\n            case InterplayTypeId.void:\n                break;\n            case InterplayTypeId.bool:\n            case InterplayTypeId.int:\n            case InterplayTypeId.uint:\n                // No special encoding required here, but cutting it down to 124bit\n                iplValue = BigInt.asUintN(124, BigInt(value));\n                break;\n            case InterplayTypeId.float: {\n                // Create a temporary buffer of size 64bit\n                const tempBuf = new ArrayBuffer(8);\n                const tempBufView = new DataView(tempBuf);\n                // Cut down the float to 64bit to match zig side\n                tempBufView.setFloat64(0, value);\n                // Extract set 64bit float as 64bit unsigned integer\n                iplValue = tempBufView.getBigUint64(0);\n                break; \n            }\n            case InterplayTypeId.bytes: {\n                // We accept Uint8array and ArrayBuffer, so we need to find a common here\n                const buf = (value instanceof Uint8Array) ? value : new Uint8Array(value);\n                iplValue = this.#encodeBytesLikeType(buf);\n                break;\n            }\n            case InterplayTypeId.string: {\n                // Encode the string to raw bytes that we can actually allocate and copy\n                const buf = this.#textEncoder.encode(value);\n                iplValue = this.#encodeBytesLikeType(buf);\n                break;\n            }\n            case InterplayTypeId.json: {\n                // Encode the string to raw bytes that we can actually allocate and copy\n                const buf = this.#textEncoder.encode(JSON.stringify(value));\n                iplValue = this.#encodeBytesLikeType(buf);\n                break;\n            }\n            case InterplayTypeId.function: {\n                // Check if we have a Zig function given to us. If so, we can just directly encode its details.\n                if(value.prototype && Object.hasOwn(value.prototype, 'origin') && Object.hasOwn(value.prototype, 'ptr') && value.prototype.origin == 0) {\n                    // Encode the pointer and origin of the zig function\n                    iplValue = (BigInt.asUintN(1, value.prototype.origin) << 32n) | BigInt.asUintN(32, value.prototype.ptr);\n                } else {\n                    // Get the next key for the new JS function\n                    const key = Object.keys(this.#functionTable).length;\n                    // Store the js function in our internal function table\n                    this.#functionTable[key] = (args) => {\n                        return value(...args)\n                    };\n                    // Encode the key as the pointer and set JS as the function origin\n                    iplValue = (BigInt.asUintN(1, 1n) << 32n) | BigInt.asUintN(32, BigInt(key));\n                }\n                break;\n            }\n            case InterplayTypeId.array: {\n                // Check if an empty array is given to us. If so, we can just leave all bits at zero.\n                if(value.length == 0) break;\n                // Calculate the length of the space we need to allocate (number of items * 128bit = number of items * 16bytes)\n                const bufLen = value.length * 16;\n                const ptr = this.#wasmAlloc(bufLen);\n                // We can view this space as an array of InterplayTypesHalf\n                const tempBuf = new BigUint64Array((this.#wasm.memory as unknown as Uint8Array).buffer, ptr, bufLen);\n                // Encode each value of the given array and store its InterplayType in the allocated buffer\n                for(let i = 0; i < value.length; i++) {\n                    const encodedEl = this.#encodeInterplayType(value[i]);\n                    \n                    tempBuf[i * 2] = encodedEl[0];\n                    tempBuf[(i * 2) + 1] = encodedEl[1];\n                }\n                // Encode the pointer and number of items\n                iplValue = (BigInt.asUintN(32, BigInt(value.length)) << 32n) | BigInt.asUintN(32, BigInt(ptr));\n                break;\n            }\n            default:\n                throw new Error(`Interplay type ${iplType} is not supported for encoding.`)\n        }\n\n        // Merge type and value to 128bit bigint\n        let fullInfo = BigInt.asUintN(4, BigInt(iplType)) | (BigInt.asUintN(124, BigInt(iplValue)) << 4n);\n        // Split 128bit bigint to two 64bit chunks\n        let r: InterplayType = [BigInt.asUintN(64, fullInfo), BigInt.asUintN(64, fullInfo >> 64n)]\n\n        return r;\n    }\n\n    /**\n     * This is a shortcut to easily read bytes like interplay types from memory. It is important to note, that this function\n     * does no return a copy of the memory section, but rather points at it. If you return this and modify it without the purpose\n     * of modifying it in the actual memory, please create a copy of this buffer.\n     * \n     * @param value interplay type that implements the bytes like interface\n     * @returns the buffer pointing to the memory section\n     */\n    #decodeBytesLikeType(value: bigint) {\n        // Extract pointer and length from the details\n        const { ptr, len } = this.#extractBitSections(value, [\n            ['ptr', 32],\n            ['len', 32],\n        ]);\n        // Return a specific uint8array for that memory region\n        return new Uint8Array((this.#wasm.memory as unknown as Uint8Array).buffer, Number(ptr), Number(len));\n    }\n\n    /**\n     * This is a shortcut to easily copy bytes like interplay types to memory. This copies the given buffer and the given buffer\n     * is free to be cleared/freed or used otherwise after this call.\n     * \n     * @param buf to copy as bytes like interplay type to wasm memory\n     * @returns encoded interplay type for this buffer\n     */\n    #encodeBytesLikeType(buf: Uint8Array): bigint {\n        const len = buf.byteLength;\n        // Allocate space in the wasm memory where we can copy these bytes\n        const ptr = this.#wasmAlloc(len);\n        // Copy the buffer data over to the wasm memory\n        new Uint8Array((this.#wasm.memory as unknown as Uint8Array).buffer, ptr, len).set(buf);\n        // Encode the pointer and length\n        return (BigInt.asUintN(32, BigInt(len)) << 32n) | BigInt.asUintN(32, BigInt(ptr));\n    }\n\n    /**\n     * Memory allocation wrapper to simplfiy typing around it. See Zig wasm_allocator for details.\n     * \n     * @param len the number of bytes to allocate\n     * @returns a ptr to the allocated space or -1 as an error\n     */\n    #wasmAlloc(len: number|bigint) {\n        const alloc = this.#wasm.alloc as (len: number) => number;\n\n        return alloc(Number(len) >>> 32);\n    }\n\n    /**\n     * Memory free wrapper to simplify typing around it. See Zig wasm_allocator for details.\n     * \n     * @param ptr pointer of the memory space to free\n     * @param len length of the region to free\n     */\n    #wasmFree(ptr: number|bigint, len: number|bigint) {\n        const free = this.#wasm.free as (ptr: number, len: number) => void;\n\n        console.log('ptr', ptr, 'len', len, 'sp', this.#wasm.stackPointer())\n\n        free(Number(ptr) >>> 32, Number(len) >>> 32)\n    }\n\n    /**\n     * As soon as a call to the WASM function os over or the return has been decoded into a JavaScript value, any allocations\n     * done for those types, on both Zig and JS side, will be freed with this function.\n     * \n     * @param value the interplay type to free the allocated resources for\n     */\n    #freeEncodedInterplayType(value: InterplayType) {\n        // TODO: Currently the base of this function is repeating code of the #decodeInterplayType function and should be reworked.\n\n        // Merge the interplay type to a single u128 value\n        const ipl = BigInt.asUintN(64, value[0]) | (BigInt.asUintN(64, value[1]) << 64n);\n\n        // Extract type and value sections\n        const { type, details } = this.#extractBitSections(ipl, [\n            ['type', 4],\n            ['details', 124]\n        ]);\n\n        // Handle all the different types\n        switch (Number(type)) {\n            case InterplayTypeId.void:\n            case InterplayTypeId.bool:\n            case InterplayTypeId.int:\n            case InterplayTypeId.uint:\n            case InterplayTypeId.float:\n                // These types don't allocate any space and are only stored in the interplay type itself.\n                break;\n            case InterplayTypeId.bytes:\n            case InterplayTypeId.string:\n            case InterplayTypeId.json: {\n                // Extract pointer and length from the details\n                const { ptr, len } = this.#extractBitSections(details, [\n                    ['ptr', 32],\n                    ['len', 32],\n                ]);\n\n                this.#wasmFree(ptr, len);\n                break;\n            }\n            case InterplayTypeId.function: {\n                // Extract pointer and origin of the function\n                const { ptr, origin } = this.#extractBitSections(details, [\n                    ['ptr', 32],\n                    ['origin', 1],\n                ])\n\n                // We only have to do a cleanup on a JavaScript function\n                if(origin === 1n) {\n                    delete this.#functionTable[Number(ptr)];\n                }\n                break;\n            }\n            case InterplayTypeId.array: {\n                // Extract pointer and number of items of the array\n                const { ptr, len } = this.#extractBitSections(details, [\n                    ['ptr', 32],\n                    ['len', 32],\n                ])\n\n                // View as array of u64, the length is twice as long as the number of items because len * 128bit = len * 2 * 64bit\n                const tempBuf = new BigUint64Array((this.#wasm.memory as unknown as Uint8Array).buffer, Number(ptr), Number(len * 2n));\n\n                for(let i = 0; i < len; i++) {\n                    const iplVariable = Array.from(tempBuf.subarray(i * 2, (i + 1) * 2)) as InterplayType;\n                    this.#freeEncodedInterplayType(iplVariable);\n                }\n\n                // Free the array itself (1item = 128 bit = 16 bytes)\n                this.#wasmFree(ptr, len * 16n);\n                break;\n            }\n            default:\n                throw new Error(`Interplay type ${type} is not supported for decoding.`)\n        }\n    }\n}\n\n/**\n * This is the equivalent to the InterplayTypeId in the interplay.zig file.\n */\nexport enum InterplayTypeId {\n    void = 0,\n    bool = 1,\n    int = 2,\n    uint = 3,\n    float = 4,\n    bytes = 5,\n    string = 6,\n    json = 7,\n    function = 8,\n    array = 9\n};"],
  "mappings": "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",
  "names": ["InterplayTypeId"]
}
