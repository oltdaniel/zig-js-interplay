var c=class{#t=void 0;#f=0;#p=new TextDecoder;#y=new TextEncoder;#r={};static async initializeFromUrl(t){let r=await fetch(t).then(e=>e.arrayBuffer());return this.initialize(r)}static async initialize(t){let r=new this,e=await WebAssembly.instantiate(t,{js:{log:(s,i)=>{let n=r.#n([s,i]).value;console.log(n)},call:(s,i,n,o)=>{let y=r.#n([s,i]).value;if(Object.getPrototypeOf(y).origin!=1)throw new Error("Function to be executed in JS expected to be of JS origin.");let p=r.#n([n,o]).value;return r.#i(y(...p))}}});return r.#I(e),r}constructor(){}#I(t){console.log(t),this.#t=t.instance.exports,this.#f=t.instance.$global0;for(let r of Object.keys(this.#t).filter(e=>!["malloc","free","memory","call"].includes(e))){if(typeof this.#t[r]!="function"){console.warn("We currently only make exported functions accessible through the Interplay Wrapper.");continue}this[r]=this.#b(r)}}#b(t){let r=this.#t[t];if(typeof r!="function")throw new Error("WASM export is not callable!");return(...e)=>this.#c(r,...e)}#c(t,...r){let e=r.map(n=>this.#i(n)),s=t(...e.flat());for(let n=0;n<e.length;n++)this.#o(e[n]);let i=s?this.#n(s).value:void 0;return i&&this.#o(s),i}#e(t,r){let e={},s=t;for(let i of r)e[i[0]]=BigInt.asUintN(i[1],s),s>>=BigInt(i[1]);return e}#d(t){return 0n}#g(t){switch(typeof t){case"string":return 6;case"number":return t%1===0?t<0?2:3:4;case"bigint":return t<0n?2:3;case"boolean":return 1;case"symbol":throw new Error(`type '${typeof t}' (value '${String(t)}') not implemented`);case"undefined":return 0;case"object":return t instanceof Uint8Array||t instanceof ArrayBuffer?5:Array.isArray(t)?9:7;case"function":return 8;default:throw new Error(`type '${typeof t}' not implemented`)}}#n(t){let r=BigInt.asUintN(64,t[0])|BigInt.asUintN(64,t[1])<<64n,{type:e,details:s}=this.#e(r,[["type",4],["details",124]]);switch(Number(e)){case 0:return{type:e};case 1:return{type:e,value:(s&0x1n)==1n};case 2:return{type:e,value:BigInt.asIntN(124,s)};case 3:return{type:e,value:BigInt.asUintN(124,s)};case 4:{let i=BigInt.asUintN(64,s),n=new ArrayBuffer(8),o=new DataView(n);return o.setBigUint64(0,i),{type:e,value:o.getFloat64(0)}}case 5:{let i=this.#s(s);return{type:e,value:i.slice()}}case 6:{let i=this.#s(s),n=this.#p.decode(i);return{type:e,value:n}}case 7:{let i=this.#s(s),n=this.#p.decode(i),o=JSON.parse(n);return{type:e,value:o}}case 8:{let i=function(...p){return this.prototype.origin==1?this.prototype.inst.#r[this.prototype.ptr](p):this.prototype.inst.#c(this.prototype.inst.#t.call,this,p)},{ptr:n,origin:o}=this.#e(s,[["ptr",32],["origin",1]]);i.prototype.ptr=n,i.prototype.origin=o,i.prototype.inst=this;let y=i.bind(i);return Object.setPrototypeOf(y,i.prototype),{type:e,value:y}}case 9:{let{ptr:i,len:n}=this.#e(s,[["ptr",32],["len",32]]),o=new BigUint64Array(this.#t.memory.buffer,Number(i),Number(n*2n)),y=[];for(let p=0;p<n;p++){let a=Array.from(o.subarray(p*2,(p+1)*2)),l=this.#n(a);y.push(l.value)}return{type:e,value:y}}default:throw new Error(`Interplay type ${e} is not supported for decoding.`)}}#i(t){let r=this.#g(t),e=0n;switch(r){case 0:break;case 1:case 2:case 3:e=BigInt.asUintN(124,BigInt(t));break;case 4:{let n=new ArrayBuffer(8),o=new DataView(n);o.setFloat64(0,t),e=o.getBigUint64(0);break}case 5:{let n=t instanceof Uint8Array?t:new Uint8Array(t);e=this.#a(n);break}case 6:{let n=this.#y.encode(t);e=this.#a(n);break}case 7:{let n=this.#y.encode(JSON.stringify(t));e=this.#a(n);break}case 8:{if(t.prototype&&Object.hasOwn(t.prototype,"origin")&&Object.hasOwn(t.prototype,"ptr")&&t.prototype.origin==0)e=BigInt.asUintN(1,t.prototype.origin)<<32n|BigInt.asUintN(32,t.prototype.ptr);else{let n=Object.keys(this.#r).length;this.#r[n]=o=>t(...o),e=BigInt.asUintN(1,1n)<<32n|BigInt.asUintN(32,BigInt(n))}break}case 9:{if(t.length==0)break;let n=t.length*16,o=this.#l(n),y=new BigUint64Array(this.#t.memory.buffer,o,n);for(let p=0;p<t.length;p++){let a=this.#i(t[p]);y[p*2]=a[0],y[p*2+1]=a[1]}e=BigInt.asUintN(32,BigInt(t.length))<<32n|BigInt.asUintN(32,BigInt(o));break}default:throw new Error(`Interplay type ${r} is not supported for encoding.`)}let s=BigInt.asUintN(4,BigInt(r))|BigInt.asUintN(124,BigInt(e))<<4n;return[BigInt.asUintN(64,s),BigInt.asUintN(64,s>>64n)]}#s(t){let{ptr:r,len:e}=this.#e(t,[["ptr",32],["len",32]]);return new Uint8Array(this.#t.memory.buffer,Number(r),Number(e))}#a(t){let r=t.byteLength,e=this.#l(r);return new Uint8Array(this.#t.memory.buffer,e,r).set(t),BigInt.asUintN(32,BigInt(r))<<32n|BigInt.asUintN(32,BigInt(e))}#l(t){let r=this.#t.alloc;return r(Number(t)>>>32)}#u(t,r){let e=this.#t.free;console.log("ptr",t,"len",r,"sp",this.#t.stackPointer()),e(Number(t)>>>32,Number(r)>>>32)}#o(t){let r=BigInt.asUintN(64,t[0])|BigInt.asUintN(64,t[1])<<64n,{type:e,details:s}=this.#e(r,[["type",4],["details",124]]);switch(Number(e)){case 0:case 1:case 2:case 3:case 4:break;case 5:case 6:case 7:{let{ptr:i,len:n}=this.#e(s,[["ptr",32],["len",32]]);this.#u(i,n);break}case 8:{let{ptr:i,origin:n}=this.#e(s,[["ptr",32],["origin",1]]);n===1n&&delete this.#r[Number(i)];break}case 9:{let{ptr:i,len:n}=this.#e(s,[["ptr",32],["len",32]]),o=new BigUint64Array(this.#t.memory.buffer,Number(i),Number(n*2n));for(let y=0;y<n;y++){let p=Array.from(o.subarray(y*2,(y+1)*2));this.#o(p)}this.#u(i,n*16n);break}default:throw new Error(`Interplay type ${e} is not supported for decoding.`)}}},u=(a=>(a[a.void=0]="void",a[a.bool=1]="bool",a[a.int=2]="int",a[a.uint=3]="uint",a[a.float=4]="float",a[a.bytes=5]="bytes",a[a.string=6]="string",a[a.json=7]="json",a[a.function=8]="function",a[a.array=9]="array",a))(u||{});export{u as InterplayTypeId,c as default};
/*!
 * @license zig-js-interplay
 *
 * Copyright (c) Daniel Oltmanns.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=interplay.min.js.map
