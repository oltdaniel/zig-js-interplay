var c=class{#t=void 0;#a=new TextDecoder;#p=new TextEncoder;#r={};static async initializeFromUrl(t){let n=await fetch(t).then(e=>e.arrayBuffer());return this.initialize(n)}static async initialize(t){let n=new this,e=await WebAssembly.instantiate(t,{js:{log:(o,i)=>{let r=n.#e([o,i]).value;console.log(r)},call:(o,i,r,a)=>{let y=n.#e([o,i]).value;if(Object.getPrototypeOf(y).origin!=1)throw new Error("Function to be executed in JS expected to be of JS origin.");let p=n.#e([r,a]).value;return n.#i(y(...p))}}});return n.#c(e),n}constructor(){}#c(t){this.#t=t.instance.exports;for(let n of Object.keys(this.#t).filter(e=>!["malloc","free","memory","call"].includes(e))){if(typeof this.#t[n]!="function"){console.warn("We currently only make exported functions accessible through the Interplay Wrapper.");continue}this[n]=this.#l(n)}}#l(t){let n=this.#t[t];if(typeof n!="function")throw new Error("WASM export is not callable!");return(...e)=>this.#y(n,...e)}#y(t,...n){let e=n.map(i=>this.#i(i)).flat(),o=t(...e);return o?this.#e(o).value:void 0}#n(t,n){let e={},o=t;for(let i of n)e[i[0]]=BigInt.asUintN(i[1],o),o>>=BigInt(i[1]);return e}#f(t){return 0n}#u(t){switch(typeof t){case"string":return 6;case"number":return t%1===0?t<0?2:3:4;case"bigint":return t<0n?2:3;case"boolean":return 1;case"symbol":throw new Error(`type '${typeof t}' (value '${String(t)}') not implemented`);case"undefined":return 0;case"object":return t instanceof Uint8Array||t instanceof ArrayBuffer?5:Array.isArray(t)?9:7;case"function":return 8;default:throw new Error(`type '${typeof t}' not implemented`)}}#e(t){let n=BigInt.asUintN(64,t[0])|BigInt.asUintN(64,t[1])<<64n,{type:e,details:o}=this.#n(n,[["type",4],["details",124]]);switch(Number(e)){case 0:return{type:e};case 1:return{type:e,value:(o&0x1n)==1n};case 2:return{type:e,value:BigInt.asIntN(124,o)};case 3:return{type:e,value:BigInt.asUintN(124,o)};case 4:{let i=BigInt.asUintN(64,o),r=new ArrayBuffer(8),a=new DataView(r);return a.setBigUint64(0,i),{type:e,value:a.getFloat64(0)}}case 5:{let i=this.#s(o);return{type:e,value:i}}case 6:{let i=this.#s(o),r=this.#a.decode(i);return{type:e,value:r}}case 7:{let i=this.#s(o),r=this.#a.decode(i),a=JSON.parse(r);return{type:e,value:a}}case 8:{let i=function(...p){return this.prototype.origin==1?this.prototype.inst.#r[this.prototype.ptr](p):this.prototype.inst.#y(this.prototype.inst.#t.call,this,p)},{ptr:r,origin:a}=this.#n(o,[["ptr",32],["origin",1]]);i.prototype.ptr=r,i.prototype.origin=a,i.prototype.inst=this;let y=i.bind(i);return Object.setPrototypeOf(y,i.prototype),{type:e,value:y}}case 9:{let{ptr:i,len:r}=this.#n(o,[["ptr",32],["len",32]]),a=new BigUint64Array(this.#t.memory.buffer,Number(i),Number(r*2n)),y=[];for(let p=0;p<r;p++){let s=Array.from(a.subarray(p*2,(p+1)*2)),l=this.#e(s);y.push(l.value)}return{type:e,value:y}}default:throw new Error(`Interplay type ${e} is not supported for decoding.`)}}#i(t){let n=this.#u(t),e=0n;switch(n){case 0:break;case 1:case 2:case 3:e=BigInt.asUintN(124,BigInt(t));break;case 4:{let r=new ArrayBuffer(8),a=new DataView(r);a.setFloat64(0,t),e=a.getBigUint64(0);break}case 5:{let r=t instanceof Uint8Array?t:new Uint8Array(t);e=this.#o(r);break}case 6:{let r=this.#p.encode(t);e=this.#o(r);break}case 7:{let r=this.#p.encode(JSON.stringify(t));e=this.#o(r);break}case 8:{if(t.prototype&&Object.hasOwn(t.prototype,"origin")&&Object.hasOwn(t.prototype,"ptr")&&t.prototype.origin==0)e=BigInt.asUintN(1,t.prototype.origin)<<32n|BigInt.asUintN(32,t.prototype.ptr);else{let r=Object.keys(this.#r).length;this.#r[r]=a=>t(...a),e=BigInt.asUintN(1,1n)<<32n|BigInt.asUintN(32,BigInt(r))}break}case 9:{if(t.length==0)break;let r=t.length*16,a=this.#t.malloc(r),y=new BigUint64Array(this.#t.memory.buffer,a,r);for(let p=0;p<t.length;p++){let s=this.#i(t[p]);y[p*2]=s[0],y[p*2+1]=s[1]}e=BigInt.asUintN(32,BigInt(t.length))<<32n|BigInt.asUintN(32,BigInt(a));break}default:throw new Error(`Interplay type ${n} is not supported for encoding.`)}let o=BigInt.asUintN(4,BigInt(n))|BigInt.asUintN(124,BigInt(e))<<4n;return[BigInt.asUintN(64,o),BigInt.asUintN(64,o>>64n)]}#s(t){let{ptr:n,len:e}=this.#n(t,[["ptr",32],["len",32]]);return new Uint8Array(this.#t.memory.buffer,Number(n),Number(e))}#o(t){let n=t.byteLength,e=this.#t.malloc(n);return new Uint8Array(this.#t.memory.buffer,e,n).set(t),BigInt.asUintN(32,BigInt(n))<<32n|BigInt.asUintN(32,BigInt(e))}},u=(s=>(s[s.void=0]="void",s[s.bool=1]="bool",s[s.int=2]="int",s[s.uint=3]="uint",s[s.float=4]="float",s[s.bytes=5]="bytes",s[s.string=6]="string",s[s.json=7]="json",s[s.function=8]="function",s[s.array=9]="array",s))(u||{});export{u as InterplayTypeId,c as default};
/*!
 * @license zig-js-interplay
 *
 * Copyright (c) Daniel Oltmanns.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=interplay.min.js.map
