var c=class{#t=void 0;#p=new TextDecoder;#y=new TextEncoder;#r={};static async initializeFromUrl(t){let i=await fetch(t).then(e=>e.arrayBuffer());return this.initialize(i)}static async initialize(t){let i=new this,e=await WebAssembly.instantiate(t,{js:{log:(s,r)=>{let n=i.#n([s,r]).value;console.log(n)},call:(s,r,n,o)=>{let y=i.#n([s,r]).value;if(Object.getPrototypeOf(y).origin!=1)throw new Error("Function to be executed in JS expected to be of JS origin.");let p=i.#n([n,o]).value;return i.#i(y(...p))}}});return i.#l(e),i}constructor(){}#l(t){this.#t=t.instance.exports;for(let i of Object.keys(this.#t).filter(e=>!["malloc","free","memory","call"].includes(e))){if(typeof this.#t[i]!="function"){console.warn("We currently only make exported functions accessible through the Interplay Wrapper.");continue}this[i]=this.#u(i)}}#u(t){let i=this.#t[t];if(typeof i!="function")throw new Error("WASM export is not callable!");return(...e)=>this.#c(i,...e)}#c(t,...i){let e=i.map(n=>this.#i(n)),s=t(...e.flat());for(let n=0;n<e.length;n++)this.#o(e[n]);let r=s?this.#n(s).value:void 0;return r&&this.#o(s),r}#e(t,i){let e={},s=t;for(let r of i)e[r[0]]=BigInt.asUintN(r[1],s),s>>=BigInt(r[1]);return e}#I(t){return 0n}#f(t){switch(typeof t){case"string":return 6;case"number":return t%1===0?t<0?2:3:4;case"bigint":return t<0n?2:3;case"boolean":return 1;case"symbol":throw new Error(`type '${typeof t}' (value '${String(t)}') not implemented`);case"undefined":return 0;case"object":return t instanceof Uint8Array||t instanceof ArrayBuffer?5:Array.isArray(t)?9:7;case"function":return 8;default:throw new Error(`type '${typeof t}' not implemented`)}}#n(t){let i=BigInt.asUintN(64,t[0])|BigInt.asUintN(64,t[1])<<64n,{type:e,details:s}=this.#e(i,[["type",4],["details",124]]);switch(Number(e)){case 0:return{type:e};case 1:return{type:e,value:(s&0x1n)==1n};case 2:return{type:e,value:BigInt.asIntN(124,s)};case 3:return{type:e,value:BigInt.asUintN(124,s)};case 4:{let r=BigInt.asUintN(64,s),n=new ArrayBuffer(8),o=new DataView(n);return o.setBigUint64(0,r),{type:e,value:o.getFloat64(0)}}case 5:{let r=this.#s(s);return{type:e,value:r.slice()}}case 6:{let r=this.#s(s),n=this.#p.decode(r);return{type:e,value:n}}case 7:{let r=this.#s(s),n=this.#p.decode(r),o=JSON.parse(n);return{type:e,value:o}}case 8:{let r=function(...p){return this.prototype.origin==1?this.prototype.inst.#r[this.prototype.ptr](p):this.prototype.inst.#c(this.prototype.inst.#t.call,this,p)},{ptr:n,origin:o}=this.#e(s,[["ptr",32],["origin",1]]);r.prototype.ptr=n,r.prototype.origin=o,r.prototype.inst=this;let y=r.bind(r);return Object.setPrototypeOf(y,r.prototype),{type:e,value:y}}case 9:{let{ptr:r,len:n}=this.#e(s,[["ptr",32],["len",32]]),o=new BigUint64Array(this.#t.memory.buffer,Number(r),Number(n*2n)),y=[];for(let p=0;p<n;p++){let a=Array.from(o.subarray(p*2,(p+1)*2)),l=this.#n(a);y.push(l.value)}return{type:e,value:y}}default:throw new Error(`Interplay type ${e} is not supported for decoding.`)}}#i(t){let i=this.#f(t),e=0n;switch(i){case 0:break;case 1:case 2:case 3:e=BigInt.asUintN(124,BigInt(t));break;case 4:{let n=new ArrayBuffer(8),o=new DataView(n);o.setFloat64(0,t),e=o.getBigUint64(0);break}case 5:{let n=t instanceof Uint8Array?t:new Uint8Array(t);e=this.#a(n);break}case 6:{let n=this.#y.encode(t);e=this.#a(n);break}case 7:{let n=this.#y.encode(JSON.stringify(t));e=this.#a(n);break}case 8:{if(t.prototype&&Object.hasOwn(t.prototype,"origin")&&Object.hasOwn(t.prototype,"ptr")&&t.prototype.origin==0)e=BigInt.asUintN(1,t.prototype.origin)<<32n|BigInt.asUintN(32,t.prototype.ptr);else{let n=Object.keys(this.#r).length;this.#r[n]=o=>t(...o),e=BigInt.asUintN(1,1n)<<32n|BigInt.asUintN(32,BigInt(n))}break}case 9:{if(t.length==0)break;let n=t.length*16,o=this.#t.malloc(n),y=new BigUint64Array(this.#t.memory.buffer,o,n);for(let p=0;p<t.length;p++){let a=this.#i(t[p]);y[p*2]=a[0],y[p*2+1]=a[1]}e=BigInt.asUintN(32,BigInt(t.length))<<32n|BigInt.asUintN(32,BigInt(o));break}default:throw new Error(`Interplay type ${i} is not supported for encoding.`)}let s=BigInt.asUintN(4,BigInt(i))|BigInt.asUintN(124,BigInt(e))<<4n;return[BigInt.asUintN(64,s),BigInt.asUintN(64,s>>64n)]}#s(t){let{ptr:i,len:e}=this.#e(t,[["ptr",32],["len",32]]);return new Uint8Array(this.#t.memory.buffer,Number(i),Number(e))}#a(t){let i=t.byteLength,e=this.#t.malloc(i);return new Uint8Array(this.#t.memory.buffer,e,i).set(t),BigInt.asUintN(32,BigInt(i))<<32n|BigInt.asUintN(32,BigInt(e))}#o(t){let i=BigInt.asUintN(64,t[0])|BigInt.asUintN(64,t[1])<<64n,{type:e,details:s}=this.#e(i,[["type",4],["details",124]]);switch(Number(e)){case 0:case 1:case 2:case 3:case 4:break;case 5:case 6:case 7:{let{ptr:r,len:n}=this.#e(s,[["ptr",32],["len",32]]);this.#t.free(Number(r),Number(n));break}case 8:{let{ptr:r,origin:n}=this.#e(s,[["ptr",32],["origin",1]]);n===1n&&delete this.#r[Number(r)];break}case 9:{let{ptr:r,len:n}=this.#e(s,[["ptr",32],["len",32]]),o=new BigUint64Array(this.#t.memory.buffer,Number(r),Number(n*2n));for(let y=0;y<n;y++){let p=Array.from(o.subarray(y*2,(y+1)*2));this.#o(p)}this.#t.free(Number(r),Number(n*16n));break}default:throw new Error(`Interplay type ${e} is not supported for decoding.`)}}},u=(a=>(a[a.void=0]="void",a[a.bool=1]="bool",a[a.int=2]="int",a[a.uint=3]="uint",a[a.float=4]="float",a[a.bytes=5]="bytes",a[a.string=6]="string",a[a.json=7]="json",a[a.function=8]="function",a[a.array=9]="array",a))(u||{});export{u as InterplayTypeId,c as default};
/*!
 * @license zig-js-interplay
 *
 * Copyright (c) Daniel Oltmanns.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=interplay.min.js.map
