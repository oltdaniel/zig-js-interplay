{
  "version": 3,
  "sources": ["../src/interplay.ts"],
  "sourcesContent": ["/*!\n * @license zig-js-interplay\n *\n * Copyright (c) Daniel Oltmanns.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntype InterplayTypeHalf = bigint;\ntype InterplayType = [InterplayTypeHalf, InterplayTypeHalf];\n\nexport default class InterplayInstance {\n    /**\n     * Hold the exports of the WASM instance. This is the core of this wrapper functionality.\n     */\n    #wasm: WebAssembly.Exports = undefined;\n\n    /**\n     * Central Text Decoder instance for converting bytes to string.\n     */\n    #textDecoder = new TextDecoder();\n\n    /**\n     * Central Text Encoder instance for converting string to bytes.\n     */\n    #textEncoder = new TextEncoder();\n\n    /**\n     * Table to assign a number to a JavaScript function in order to remember\n     * it by an unique id and being able to call it again if necessary.\n     */\n    #functionTable: {[key: number]: Function} = {};\n\n    /**\n     * There will be functions assigned by name from the WASM exports and made accessible directly.\n     */\n    [key: string]: Function;\n\n    /**\n     * Initialize a new Wrapper instance from an url which is loaded in async via fetch.\n     * \n     * @param wasmUrl URL to given wasm file that should be loaded\n     * @returns new instance of the ZigWASMWrapper for this wasm file\n     */\n    static async initializeFromUrl(wasmUrl: URL): Promise<InterplayInstance> {\n        const rawWasm = await fetch(wasmUrl).then(resp => resp.arrayBuffer());\n\n        return this.initialize(rawWasm);\n    }\n\n    /**\n     * Initialize a new Wrapper directly from the raw WASM bytes.\n     * \n     * @param rawModule raw bytes of the wasm module to initialize\n     * @returns new instance of the ZigWASMWrapper for this wasm file\n     */\n    static async initialize(rawModule: BufferSource): Promise<InterplayInstance> {\n        const inst = new this();\n\n        const obj = await WebAssembly.instantiate(rawModule, {\n            js: {\n                log: (arg: InterplayTypeHalf, arg2: InterplayTypeHalf) => {\n                    let message = inst.#decodeInterplayType([arg, arg2]).value;\n                    console.log(message);\n                },\n                call: (func: InterplayTypeHalf, func2: InterplayTypeHalf, args: InterplayTypeHalf, args2: InterplayTypeHalf) => {\n                    let f = inst.#decodeInterplayType([func, func2]).value;\n\n                    if(Object.getPrototypeOf(f).origin != 1) {\n                        throw new Error('Function to be executed in JS expected to be of JS origin.');\n                    }\n\n                    let a = inst.#decodeInterplayType([args, args2]).value;\n\n                    return inst.#encodeInterplayType(f(...a));\n                }\n            },\n        })\n\n        inst.#loadWasmObj(obj);\n\n        return inst;\n    }\n\n    constructor() {}\n\n    /**\n     * This function does some initialization for a loaded WASM module and raises the WASM exports to functions directly\n     * accessible from this very class instance via the interplay wrapper.\n     * \n     * @param obj the instantiated WASM source for which this class has been created\n     */\n    #loadWasmObj(obj: WebAssembly.WebAssemblyInstantiatedSource) {\n        this.#wasm = obj.instance.exports;\n\n        // Expose the exported custom functions that are not implementation relevant\n        for (let name of Object.keys(this.#wasm).filter(n => !['malloc', 'free', 'memory', 'call'].includes(n))) {\n            // Make sure we only wrap exported functions\n            if(typeof this.#wasm[name] !== 'function') {\n                // TODO: Parse constants as well and expose them via getter methods.\n                console.warn('We currently only make exported functions accessible through the Interplay Wrapper.')\n                continue;\n            }\n\n            this[name] = this.#wrappedCallHandler(name)\n        }\n    }\n\n    /**\n     * This not only returns a wrapped function handler, it also checks of the actual export is even a function that we could\n     * call. This should only be called if the caller is sure, the named export is actually a function.\n     * \n     * @param funcName name of the exported wasm function to wrap\n     * @returns handler function for a wrapped call to the named function\n     */\n    #wrappedCallHandler(funcName: string): Function {\n        const wasmFunc = this.#wasm[funcName];\n\n        // Verify the \n        if(typeof wasmFunc !== 'function') throw new Error('WASM export is not callable!');\n\n        return (...args): any => {\n            return this.#wrappedCall(wasmFunc, ...args)\n        }\n    }\n\n    /**\n     * This function abstracts the complexity of calling a WASM exported function directly with JavaScript values of any kind\n     * without thinking about the Interplay Types. The arguments will be automatically converted and the return will be\n     * parsed. This means, there is no need to think about Interplay Types outside of these wrapped calls.\n     * \n     * It is important to not ate this point, allocated resources for converting JavaScript values to Interplay Types will be\n     * automatically freed after the call to the underlying WASM function finished. Values used within the WASM module after\n     * their use within the function block, should not be done. Instead a full copy of that value is necessary.\n     * \n     * @param func name of the function from the WASM exports\n     * @param args arguments that should be converted to Interplay Types\n     * @returns parsed Interplay Type from the return value of that function\n     */\n    #wrappedCall(func: Function, ...args) {\n        // Encode the arguments to interplay types and flatten the array.\n        // The exported wasm functions only accept direct arguments, no arrays or other types.\n        const wasmArgs = args.map(a => this.#encodeInterplayType(a)).flat()\n\n        const r = func(...wasmArgs);\n\n        // There is no need for the wasm function to return something. So we only decode interplay types if we received\n        // an actual value as a return.\n        return r ? this.#decodeInterplayType(r).value : undefined;\n    }\n\n    /**\n     * Each InterplayType in Zig is a packed struct of size u128 of which the first 4bit are its type notation. The\n     * reamaining bits can be used as desired for each type, requireing to parse different sections of different use\n     * and size. This function abstracts this to avoid repeating code but introducing a small performance penalty.\n     * \n     * @param value the raw value of bits from where the section values will be extracted\n     * @param sections the sections in which exact order their values of X bits will be extracted\n     * @returns an object with the section name as key and extracted bits as value\n     */\n    #extractBitSections(value: bigint, sections: Array<[string, number]>)  {\n        const r: {[key: string]: bigint} = {};\n\n        let bits = value;\n        for(const section of sections) {\n            r[section[0]] = BigInt.asUintN(section[1], bits);\n            bits >>= BigInt(section[1]);\n        }\n\n        return r;\n    }\n\n    // TODO: Implement this to avoid weird lines of code for encoding\n    #packBitSections(sections: Array<[string, number, bigint]>): bigint { return 0n }\n\n    /**\n     * Detect the correct InterplayTypeId for any JS value. If the type is not supported, we throw an error.\n     * \n     * @param value the value of which the InterplayTypeId should be detected from\n     * @returns the detected InterplayTypeId\n     */\n    #mapValueToInterplayTypeId(value: any): InterplayTypeId {\n        switch (typeof value) {\n            case 'string':\n                return InterplayTypeId.string;\n            case 'number':\n                return ((value % 1) === 0) ? (value < 0) ? InterplayTypeId.int : InterplayTypeId.uint : InterplayTypeId.float;\n            case 'bigint':\n                return (value < 0n) ? InterplayTypeId.int : InterplayTypeId.uint;\n            case 'boolean':\n                return InterplayTypeId.bool;\n            case 'symbol':\n                throw new Error(`type '${typeof value}' (value '${String(value)}') not implemented`)\n            case 'undefined':\n                return InterplayTypeId.void;\n            case 'object': {\n                if (value instanceof Uint8Array || value instanceof ArrayBuffer) {\n                    return InterplayTypeId.bytes;\n                }\n                if(Array.isArray(value)) {\n                    return InterplayTypeId.array;\n                }\n                return InterplayTypeId.json;\n            }\n            case 'function':\n                return InterplayTypeId.function;\n            default:\n                // NOTE: This is just in case, this should be unreachable\n                throw new Error(`type '${typeof value}' not implemented`)\n        }\n    }\n\n    /**\n     * \n     * @param value \n     */\n    #decodeInterplayType(value: InterplayType): any {\n        // Merge the interplay type to a single u128 value\n        const ipl = BigInt.asUintN(64, value[0]) | (BigInt.asUintN(64, value[1]) << 64n);\n\n        // Extract type and value sections\n        const { type, details } = this.#extractBitSections(ipl, [\n            ['type', 4],\n            ['details', 124]\n        ]);\n\n        switch (Number(type)) {\n            case InterplayTypeId.void:\n                return { type };\n            case InterplayTypeId.bool:\n                return { type, value: ((details & 0x1n) == 1n) ? true : false };\n            case InterplayTypeId.int:\n                return { type, value: BigInt.asIntN(124, details) };\n            case InterplayTypeId.uint:\n                return { type, value: BigInt.asUintN(124, details) };\n            case InterplayTypeId.float: {\n                // We only care about the first 64bit for the float\n                const rawFloatValue = BigInt.asUintN(64, details);\n\n                // Move the value into a correct representation\n                const tempBuf = new ArrayBuffer(8);\n                const tempBufView = new DataView(tempBuf);\n                tempBufView.setBigUint64(0, rawFloatValue);\n\n                // Return correct float value\n                return { type, value: tempBufView.getFloat64(0) };\n            }\n            case InterplayTypeId.bytes: {\n                const buf = this.#decodeBytesLikeType(details);\n\n                return { type, value: buf };\n            }\n            case InterplayTypeId.string: {\n                const buf = this.#decodeBytesLikeType(details);\n                const str = this.#textDecoder.decode(buf);\n\n                return { type, value: str };\n            }\n            case InterplayTypeId.json: {\n                const buf = this.#decodeBytesLikeType(details);\n                const str = this.#textDecoder.decode(buf);\n                const json = JSON.parse(str)\n\n                return { type, value: json };\n            }\n            case InterplayTypeId.function: {\n                // Create a function that behaves just like a JavaScript function\n                const f = function (...args) {\n                    // If the function is of JavaScript origin, we can just call it straight from the function table\n                    if(this.prototype.origin == 1) {\n                        return this.prototype.inst.#functionTable[this.prototype.ptr](args)\n                    } else {\n                        // Else we do a wrapped call to the referenced zig function\n                        return this.prototype.inst.#wrappedCall(this.prototype.inst.#wasm.call, this, args);\n                    }\n                }\n                // Extract pointer and origin of the function\n                const { ptr, origin } = this.#extractBitSections(details, [\n                    ['ptr', 32],\n                    ['origin', 1],\n                ])\n\n                // Store function attributes in prototype so we can recoginize it again\n                f.prototype.ptr = ptr;\n                f.prototype.origin = origin;\n                f.prototype.inst = this;\n\n                // Bind it to itself so we can reference this within the function\n                const boundF = f.bind(f);\n                // Copy over the prototype to the bound function\n                Object.setPrototypeOf(boundF, f.prototype);\n\n                return { type, value: boundF };\n            }\n            case InterplayTypeId.array: {\n                // Extract pointer and number of items of the array\n                const { ptr, len } = this.#extractBitSections(details, [\n                    ['ptr', 32],\n                    ['len', 32],\n                ])\n\n                // View as array of u64, the length is twice as long as the number of items because len * 128bit = len * 2 * 64bit\n                const tempBuf = new BigUint64Array((this.#wasm.memory as unknown as Uint8Array).buffer, Number(ptr), Number(len * 2n));\n\n                const decodedArray = [];\n                for(let i = 0; i < len; i++) {\n                    const iplVariable = Array.from(tempBuf.subarray(i * 2, (i + 1) * 2)) as InterplayType;\n                    const variable = this.#decodeInterplayType(iplVariable);\n\n                    decodedArray.push(variable.value);\n                }\n\n                return { type, value: decodedArray };\n            }\n            default:\n                throw new Error(`Interplay type ${type} is not supported for decoding.`)\n        }\n    }\n\n    /**\n     * \n     * @param value \n     * @returns \n     */\n    #encodeInterplayType(value: any): InterplayType {\n        // Detect interplay type for the value so we can continue to encode it\n        const iplType = this.#mapValueToInterplayTypeId(value);\n        // Temporary placeholder for the value within the interplay type\n        let iplValue: bigint = 0n;\n\n        switch (iplType) {\n            case InterplayTypeId.void:\n                break;\n            case InterplayTypeId.bool:\n            case InterplayTypeId.int:\n            case InterplayTypeId.uint:\n                // No special encoding required here, but cutting it down to 124bit\n                iplValue = BigInt.asUintN(124, BigInt(value));\n                break;\n            case InterplayTypeId.float: {\n                // Create a temporary buffer of size 64bit\n                const tempBuf = new ArrayBuffer(8);\n                const tempBufView = new DataView(tempBuf);\n                // Cut down the float to 64bit to match zig side\n                tempBufView.setFloat64(0, value);\n                // Extract set 64bit float as 64bit unsigned integer\n                iplValue = tempBufView.getBigUint64(0);\n                break; \n            }\n            case InterplayTypeId.bytes: {\n                // We accept Uint8array and ArrayBuffer, so we need to find a common here\n                const buf = (value instanceof Uint8Array) ? value : new Uint8Array(value);\n                iplValue = this.#encodeBytesLikeType(buf);\n                break;\n            }\n            case InterplayTypeId.string: {\n                // Encode the string to raw bytes that we can actually allocate and copy\n                const buf = this.#textEncoder.encode(value);\n                iplValue = this.#encodeBytesLikeType(buf);\n                break;\n            }\n            case InterplayTypeId.json: {\n                // Encode the string to raw bytes that we can actually allocate and copy\n                const buf = this.#textEncoder.encode(JSON.stringify(value));\n                iplValue = this.#encodeBytesLikeType(buf);\n                break;\n            }\n            case InterplayTypeId.function: {\n                // Check if we have a Zig function given to us. If so, we can just directly encode its details.\n                if(value.prototype && Object.hasOwn(value.prototype, 'origin') && Object.hasOwn(value.prototype, 'ptr') && value.prototype.origin == 0) {\n                    // Encode the pointer and origin of the zig function\n                    iplValue = (BigInt.asUintN(1, value.prototype.origin) << 32n) | BigInt.asUintN(32, value.prototype.ptr);\n                } else {\n                    // Get the next key for the new JS function\n                    const key = Object.keys(this.#functionTable).length;\n                    // Store the js function in our internal function table\n                    this.#functionTable[key] = (args) => {\n                        return value(...args)\n                    };\n                    // Encode the key as the pointer and set JS as the function origin\n                    iplValue = (BigInt.asUintN(1, 1n) << 32n) | BigInt.asUintN(32, BigInt(key));\n                }\n                break;\n            }\n            case InterplayTypeId.array: {\n                // Check if an empty array is given to us. If so, we can just leave all bits at zero.\n                if(value.length == 0) break;\n                // Calculate the length of the space we need to allocate (number of items * 128bit = number of items * 16bytes)\n                const bufLen = value.length * 16;\n                const ptr = (this.#wasm.malloc as Function)(bufLen);\n                // We can view this space as an array of InterplayTypesHalf\n                const tempBuf = new BigUint64Array((this.#wasm.memory as unknown as Uint8Array).buffer, ptr, bufLen);\n                // Encode each value of the given array and store its InterplayType in the allocated buffer\n                for(let i = 0; i < value.length; i++) {\n                    const encodedEl = this.#encodeInterplayType(value[i]);\n                    \n                    tempBuf[i * 2] = encodedEl[0];\n                    tempBuf[(i * 2) + 1] = encodedEl[1];\n                }\n                // Encode the pointer and number of items\n                iplValue = (BigInt.asUintN(32, BigInt(value.length)) << 32n) | BigInt.asUintN(32, BigInt(ptr));\n                break;\n            }\n            default:\n                throw new Error(`Interplay type ${iplType} is not supported for encoding.`)\n        }\n\n        // Merge type and value to 128bit bigint\n        let fullInfo = BigInt.asUintN(4, BigInt(iplType)) | (BigInt.asUintN(124, BigInt(iplValue)) << 4n);\n        // Split 128bit bigint to two 64bit chunks\n        let r: InterplayType = [BigInt.asUintN(64, fullInfo), BigInt.asUintN(64, fullInfo >> 64n)]\n\n        return r;\n    }\n\n    #decodeBytesLikeType(value: bigint) {\n        // Extract pointer and length from the details\n        const { ptr, len } = this.#extractBitSections(value, [\n            ['ptr', 32],\n            ['len', 32],\n        ]);\n        // Return a specific uint8array for that memory region\n        return new Uint8Array((this.#wasm.memory as unknown as Uint8Array).buffer, Number(ptr), Number(len));\n    }\n\n    #encodeBytesLikeType(buf: Uint8Array): bigint {\n        const len = buf.byteLength;\n        // Allocate space in the wasm memory where we can copy these bytes\n        const ptr = (this.#wasm.malloc as Function)(len);\n        // Copy the buffer data over to the wasm memory\n        new Uint8Array((this.#wasm.memory as unknown as Uint8Array).buffer, ptr, len).set(buf);\n        // Encode the pointer and length\n        return (BigInt.asUintN(32, BigInt(len)) << 32n) | BigInt.asUintN(32, BigInt(ptr));\n    }\n}\n\n/**\n * This is the equivalent to the InterplayTypeId in the interplay.zig file.\n */\nexport enum InterplayTypeId {\n    void = 0,\n    bool = 1,\n    int = 2,\n    uint = 3,\n    float = 4,\n    bytes = 5,\n    string = 6,\n    json = 7,\n    function = 8,\n    array = 9\n};"],
  "mappings": "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",
  "names": ["InterplayInstance", "#wasm", "#textDecoder", "#textEncoder", "#functionTable", "wasmUrl", "rawWasm", "resp", "rawModule", "inst", "obj", "arg", "arg2", "message", "#decodeInterplayType", "func", "func2", "args", "args2", "f", "a", "#encodeInterplayType", "#loadWasmObj", "name", "n", "#wrappedCallHandler", "funcName", "wasmFunc", "#wrappedCall", "wasmArgs", "r", "#extractBitSections", "value", "sections", "bits", "section", "#packBitSections", "#mapValueToInterplayTypeId", "ipl", "type", "details", "rawFloatValue", "tempBuf", "tempBufView", "buf", "#decodeBytesLikeType", "str", "json", "ptr", "origin", "boundF", "len", "decodedArray", "i", "iplVariable", "variable", "iplType", "iplValue", "#encodeBytesLikeType", "key", "bufLen", "encodedEl", "fullInfo", "InterplayTypeId"]
}
