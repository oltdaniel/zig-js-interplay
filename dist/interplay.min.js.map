{
  "version": 3,
  "sources": ["../src/interplay.ts"],
  "sourcesContent": ["/*!\n * @license zig-js-interplay\n *\n * Copyright (c) Daniel Oltmanns.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntype InterplayTypeHalf = bigint;\ntype InterplayType = [InterplayTypeHalf, InterplayTypeHalf];\n\nexport default class InterplayInstance {\n    /**\n     * Hold the exports of the WASM instance. This is the core of this wrapper functionality.\n     */\n    #wasm: WebAssembly.Exports = undefined;\n\n    /**\n     * This will be overwritten by an exported global which indicates the protected memory which\n     * should not be freed.\n     */\n    #wasmMemoryDataPtr: number = 0;\n\n    /**\n     * Central Text Decoder instance for converting bytes to string.\n     */\n    #textDecoder = new TextDecoder();\n\n    /**\n     * Central Text Encoder instance for converting string to bytes.\n     */\n    #textEncoder = new TextEncoder();\n\n    /**\n     * Table to assign a number to a JavaScript function in order to remember\n     * it by an unique id and being able to call it again if necessary.\n     */\n    #functionTable: {[key: number]: Function} = {};\n\n    /**\n     * There will be functions assigned by name from the WASM exports and made accessible directly.\n     */\n    [key: string]: Function;\n\n    /**\n     * Initialize a new Wrapper instance from an url which is loaded in async via fetch.\n     * \n     * @param wasmUrl URL to given wasm file that should be loaded\n     * @returns new instance of the ZigWASMWrapper for this wasm file\n     */\n    static async initializeFromUrl(wasmUrl: URL): Promise<InterplayInstance> {\n        const rawWasm = await fetch(wasmUrl).then(resp => resp.arrayBuffer());\n\n        return this.initialize(rawWasm);\n    }\n\n    /**\n     * Initialize a new Wrapper directly from the raw WASM bytes.\n     * \n     * @param rawModule raw bytes of the wasm module to initialize\n     * @returns new instance of the ZigWASMWrapper for this wasm file\n     */\n    static async initialize(rawModule: BufferSource): Promise<InterplayInstance> {\n        const inst = new this();\n\n        const obj = await WebAssembly.instantiate(rawModule, {\n            js: {\n                log: (arg: InterplayTypeHalf, arg2: InterplayTypeHalf) => {\n                    let message = inst.#decodeInterplayType([arg, arg2]).value;\n                    console.log(message);\n                },\n                call: (func: InterplayTypeHalf, func2: InterplayTypeHalf, args: InterplayTypeHalf, args2: InterplayTypeHalf) => {\n                    let f = inst.#decodeInterplayType([func, func2]).value;\n\n                    if(Object.getPrototypeOf(f).origin != 1) {\n                        throw new Error('Function to be executed in JS expected to be of JS origin.');\n                    }\n\n                    let a = inst.#decodeInterplayType([args, args2]).value;\n\n                    return inst.#encodeInterplayType(f(...a));\n                }\n            },\n        })\n\n        inst.#loadWasmObj(obj);\n\n        return inst;\n    }\n\n    constructor() {}\n\n    /**\n     * This function does some initialization for a loaded WASM module and raises the WASM exports to functions directly\n     * accessible from this very class instance via the interplay wrapper.\n     * \n     * @param obj the instantiated WASM source for which this class has been created\n     */\n    #loadWasmObj(obj: WebAssembly.WebAssemblyInstantiatedSource) {\n        console.log(obj)\n\n        this.#wasm = obj.instance.exports;\n\n        this.#wasmMemoryDataPtr = obj.instance['$global0'];\n\n        // Expose the exported custom functions that are not implementation relevant\n        for (let name of Object.keys(this.#wasm).filter(n => !['malloc', 'free', 'memory', 'call'].includes(n))) {\n            // Make sure we only wrap exported functions\n            if(typeof this.#wasm[name] !== 'function') {\n                // TODO: Parse constants as well and expose them via getter methods.\n                console.warn('We currently only make exported functions accessible through the Interplay Wrapper.')\n                continue;\n            }\n\n            this[name] = this.#wrappedCallHandler(name)\n        }\n    }\n\n    /**\n     * This not only returns a wrapped function handler, it also checks of the actual export is even a function that we could\n     * call. This should only be called if the caller is sure, the named export is actually a function.\n     * \n     * @param funcName name of the exported wasm function to wrap\n     * @returns handler function for a wrapped call to the named function\n     */\n    #wrappedCallHandler(funcName: string): Function {\n        const wasmFunc = this.#wasm[funcName];\n\n        // Verify the \n        if(typeof wasmFunc !== 'function') throw new Error('WASM export is not callable!');\n\n        return (...args): any => {\n            return this.#wrappedCall(wasmFunc, ...args)\n        }\n    }\n\n    /**\n     * This function abstracts the complexity of calling a WASM exported function directly with JavaScript values of any kind\n     * without thinking about the Interplay Types. The arguments will be automatically converted and the return will be\n     * parsed. This means, there is no need to think about Interplay Types outside of these wrapped calls.\n     * \n     * It is important to not ate this point, allocated resources for converting JavaScript values to Interplay Types will be\n     * automatically freed after the call to the underlying WASM function finished. Values used within the WASM module after\n     * their use within the function block, should not be done. Instead a full copy of that value is necessary.\n     * \n     * @param func name of the function from the WASM exports\n     * @param args arguments that should be converted to Interplay Types\n     * @returns parsed Interplay Type from the return value of that function\n     */\n    #wrappedCall(func: Function, ...args) {\n        // Encode the arguments to interplay types.\n        const wasmArgs = args.map(a => this.#encodeInterplayType(a))\n\n        // Call the underlying function with a flatten array of the encoded types.\n        // The exported wasm functions only accept direct arguments, no arrays or other types.\n        const r = func(...wasmArgs.flat());\n\n        // Free each previosuly argument if there has been an allocation\n        for(let i = 0; i < wasmArgs.length; i++) {\n            this.#freeEncodedInterplayType(wasmArgs[i]);\n        }\n\n        // Correctly decode thhe optional return of the wasm function\n        const wasmReturn = r ? this.#decodeInterplayType(r).value : undefined;\n\n        // Free the interplay type of the return if present and after decoding\n        if(wasmReturn) {\n            this.#freeEncodedInterplayType(r);\n        }\n\n        // There is no need for the wasm function to return something. So we only decode interplay types if we received\n        // an actual value as a return.\n        return wasmReturn;\n    }\n\n    /**\n     * Each InterplayType in Zig is a packed struct of size u128 of which the first 4bit are its type notation. The\n     * reamaining bits can be used as desired for each type, requireing to parse different sections of different use\n     * and size. This function abstracts this to avoid repeating code but introducing a small performance penalty.\n     * \n     * @param value the raw value of bits from where the section values will be extracted\n     * @param sections the sections in which exact order their values of X bits will be extracted\n     * @returns an object with the section name as key and extracted bits as value\n     */\n    #extractBitSections(value: bigint, sections: Array<[string, number]>)  {\n        const r: {[key: string]: bigint} = {};\n\n        let bits = value;\n        for(const section of sections) {\n            r[section[0]] = BigInt.asUintN(section[1], bits);\n            bits >>= BigInt(section[1]);\n        }\n\n        return r;\n    }\n\n    // TODO: Implement this to avoid weird lines of code for encoding\n    #packBitSections(sections: Array<[string, number, bigint]>): bigint { return 0n }\n\n    /**\n     * Detect the correct InterplayTypeId for any JS value. If the type is not supported, we throw an error.\n     * \n     * @param value the value of which the InterplayTypeId should be detected from\n     * @returns the detected InterplayTypeId\n     */\n    #mapValueToInterplayTypeId(value: any): InterplayTypeId {\n        switch (typeof value) {\n            case 'string':\n                return InterplayTypeId.string;\n            case 'number':\n                return ((value % 1) === 0) ? (value < 0) ? InterplayTypeId.int : InterplayTypeId.uint : InterplayTypeId.float;\n            case 'bigint':\n                return (value < 0n) ? InterplayTypeId.int : InterplayTypeId.uint;\n            case 'boolean':\n                return InterplayTypeId.bool;\n            case 'symbol':\n                throw new Error(`type '${typeof value}' (value '${String(value)}') not implemented`)\n            case 'undefined':\n                return InterplayTypeId.void;\n            case 'object': {\n                if (value instanceof Uint8Array || value instanceof ArrayBuffer) {\n                    return InterplayTypeId.bytes;\n                }\n                if(Array.isArray(value)) {\n                    return InterplayTypeId.array;\n                }\n                return InterplayTypeId.json;\n            }\n            case 'function':\n                return InterplayTypeId.function;\n            default:\n                // NOTE: This is just in case, this should be unreachable\n                throw new Error(`type '${typeof value}' not implemented`)\n        }\n    }\n\n    /**\n     * Decode a given Interplay Type to its JavaScript value. Any allocations done to the interplay type can be freed\n     * after this call, as the return value does not depend on the origin value.\n     * \n     * @param value interplay type to decode\n     * @returns decoded interplay type as javascript value\n     */\n    #decodeInterplayType(value: InterplayType): any {\n        // Merge the interplay type to a single u128 value\n        const ipl = BigInt.asUintN(64, value[0]) | (BigInt.asUintN(64, value[1]) << 64n);\n\n        // Extract type and value sections\n        const { type, details } = this.#extractBitSections(ipl, [\n            ['type', 4],\n            ['details', 124]\n        ]);\n\n        switch (Number(type)) {\n            case InterplayTypeId.void:\n                return { type };\n            case InterplayTypeId.bool:\n                return { type, value: ((details & 0x1n) == 1n) ? true : false };\n            case InterplayTypeId.int:\n                return { type, value: BigInt.asIntN(124, details) };\n            case InterplayTypeId.uint:\n                return { type, value: BigInt.asUintN(124, details) };\n            case InterplayTypeId.float: {\n                // We only care about the first 64bit for the float\n                const rawFloatValue = BigInt.asUintN(64, details);\n\n                // Move the value into a correct representation\n                const tempBuf = new ArrayBuffer(8);\n                const tempBufView = new DataView(tempBuf);\n                tempBufView.setBigUint64(0, rawFloatValue);\n\n                // Return correct float value\n                return { type, value: tempBufView.getFloat64(0) };\n            }\n            case InterplayTypeId.bytes: {\n                const buf = this.#decodeBytesLikeType(details);\n\n                // NOTE: It is important to slice as the buf is only pointing to the raw WASM memory section\n                return { type, value: buf.slice() };\n            }\n            case InterplayTypeId.string: {\n                const buf = this.#decodeBytesLikeType(details);\n                const str = this.#textDecoder.decode(buf);\n\n                return { type, value: str };\n            }\n            case InterplayTypeId.json: {\n                const buf = this.#decodeBytesLikeType(details);\n                const str = this.#textDecoder.decode(buf);\n                const json = JSON.parse(str)\n\n                return { type, value: json };\n            }\n            case InterplayTypeId.function: {\n                // Create a function that behaves just like a JavaScript function\n                const f = function (...args) {\n                    // If the function is of JavaScript origin, we can just call it straight from the function table\n                    if(this.prototype.origin == 1) {\n                        return this.prototype.inst.#functionTable[this.prototype.ptr](args)\n                    } else {\n                        // Else we do a wrapped call to the referenced zig function\n                        return this.prototype.inst.#wrappedCall(this.prototype.inst.#wasm.call, this, args);\n                    }\n                }\n                // Extract pointer and origin of the function\n                const { ptr, origin } = this.#extractBitSections(details, [\n                    ['ptr', 32],\n                    ['origin', 1],\n                ])\n\n                // Store function attributes in prototype so we can recoginize it again\n                f.prototype.ptr = ptr;\n                f.prototype.origin = origin;\n                f.prototype.inst = this;\n\n                // Bind it to itself so we can reference this within the function\n                const boundF = f.bind(f);\n                // Copy over the prototype to the bound function\n                Object.setPrototypeOf(boundF, f.prototype);\n\n                return { type, value: boundF };\n            }\n            case InterplayTypeId.array: {\n                // Extract pointer and number of items of the array\n                const { ptr, len } = this.#extractBitSections(details, [\n                    ['ptr', 32],\n                    ['len', 32],\n                ])\n\n                // View as array of u64, the length is twice as long as the number of items because len * 128bit = len * 2 * 64bit\n                const tempBuf = new BigUint64Array((this.#wasm.memory as unknown as Uint8Array).buffer, Number(ptr), Number(len * 2n));\n\n                const decodedArray = [];\n                for(let i = 0; i < len; i++) {\n                    const iplVariable = Array.from(tempBuf.subarray(i * 2, (i + 1) * 2)) as InterplayType;\n                    const variable = this.#decodeInterplayType(iplVariable);\n\n                    decodedArray.push(variable.value);\n                }\n\n                return { type, value: decodedArray };\n            }\n            default:\n                throw new Error(`Interplay type ${type} is not supported for decoding.`)\n        }\n    }\n\n    /**\n     * Encode a JavaScript value to the corresponding interplay type. This may require allocation in memory in order to\n     * transfer the full value to the WASM environment. There is no automatic free and this needs to be done manually\n     * after the interplay type has been used.\n     * \n     * @param value javascript value to encode\n     * @returns encoded javascript value as interplay type\n     */\n    #encodeInterplayType(value: any): InterplayType {\n        // Detect interplay type for the value so we can continue to encode it\n        const iplType = this.#mapValueToInterplayTypeId(value);\n        // Temporary placeholder for the value within the interplay type\n        let iplValue: bigint = 0n;\n\n        switch (iplType) {\n            case InterplayTypeId.void:\n                break;\n            case InterplayTypeId.bool:\n            case InterplayTypeId.int:\n            case InterplayTypeId.uint:\n                // No special encoding required here, but cutting it down to 124bit\n                iplValue = BigInt.asUintN(124, BigInt(value));\n                break;\n            case InterplayTypeId.float: {\n                // Create a temporary buffer of size 64bit\n                const tempBuf = new ArrayBuffer(8);\n                const tempBufView = new DataView(tempBuf);\n                // Cut down the float to 64bit to match zig side\n                tempBufView.setFloat64(0, value);\n                // Extract set 64bit float as 64bit unsigned integer\n                iplValue = tempBufView.getBigUint64(0);\n                break; \n            }\n            case InterplayTypeId.bytes: {\n                // We accept Uint8array and ArrayBuffer, so we need to find a common here\n                const buf = (value instanceof Uint8Array) ? value : new Uint8Array(value);\n                iplValue = this.#encodeBytesLikeType(buf);\n                break;\n            }\n            case InterplayTypeId.string: {\n                // Encode the string to raw bytes that we can actually allocate and copy\n                const buf = this.#textEncoder.encode(value);\n                iplValue = this.#encodeBytesLikeType(buf);\n                break;\n            }\n            case InterplayTypeId.json: {\n                // Encode the string to raw bytes that we can actually allocate and copy\n                const buf = this.#textEncoder.encode(JSON.stringify(value));\n                iplValue = this.#encodeBytesLikeType(buf);\n                break;\n            }\n            case InterplayTypeId.function: {\n                // Check if we have a Zig function given to us. If so, we can just directly encode its details.\n                if(value.prototype && Object.hasOwn(value.prototype, 'origin') && Object.hasOwn(value.prototype, 'ptr') && value.prototype.origin == 0) {\n                    // Encode the pointer and origin of the zig function\n                    iplValue = (BigInt.asUintN(1, value.prototype.origin) << 32n) | BigInt.asUintN(32, value.prototype.ptr);\n                } else {\n                    // Get the next key for the new JS function\n                    const key = Object.keys(this.#functionTable).length;\n                    // Store the js function in our internal function table\n                    this.#functionTable[key] = (args) => {\n                        return value(...args)\n                    };\n                    // Encode the key as the pointer and set JS as the function origin\n                    iplValue = (BigInt.asUintN(1, 1n) << 32n) | BigInt.asUintN(32, BigInt(key));\n                }\n                break;\n            }\n            case InterplayTypeId.array: {\n                // Check if an empty array is given to us. If so, we can just leave all bits at zero.\n                if(value.length == 0) break;\n                // Calculate the length of the space we need to allocate (number of items * 128bit = number of items * 16bytes)\n                const bufLen = value.length * 16;\n                const ptr = this.#wasmAlloc(bufLen);\n                // We can view this space as an array of InterplayTypesHalf\n                const tempBuf = new BigUint64Array((this.#wasm.memory as unknown as Uint8Array).buffer, ptr, bufLen);\n                // Encode each value of the given array and store its InterplayType in the allocated buffer\n                for(let i = 0; i < value.length; i++) {\n                    const encodedEl = this.#encodeInterplayType(value[i]);\n                    \n                    tempBuf[i * 2] = encodedEl[0];\n                    tempBuf[(i * 2) + 1] = encodedEl[1];\n                }\n                // Encode the pointer and number of items\n                iplValue = (BigInt.asUintN(32, BigInt(value.length)) << 32n) | BigInt.asUintN(32, BigInt(ptr));\n                break;\n            }\n            default:\n                throw new Error(`Interplay type ${iplType} is not supported for encoding.`)\n        }\n\n        // Merge type and value to 128bit bigint\n        let fullInfo = BigInt.asUintN(4, BigInt(iplType)) | (BigInt.asUintN(124, BigInt(iplValue)) << 4n);\n        // Split 128bit bigint to two 64bit chunks\n        let r: InterplayType = [BigInt.asUintN(64, fullInfo), BigInt.asUintN(64, fullInfo >> 64n)]\n\n        return r;\n    }\n\n    /**\n     * This is a shortcut to easily read bytes like interplay types from memory. It is important to note, that this function\n     * does no return a copy of the memory section, but rather points at it. If you return this and modify it without the purpose\n     * of modifying it in the actual memory, please create a copy of this buffer.\n     * \n     * @param value interplay type that implements the bytes like interface\n     * @returns the buffer pointing to the memory section\n     */\n    #decodeBytesLikeType(value: bigint) {\n        // Extract pointer and length from the details\n        const { ptr, len } = this.#extractBitSections(value, [\n            ['ptr', 32],\n            ['len', 32],\n        ]);\n        // Return a specific uint8array for that memory region\n        return new Uint8Array((this.#wasm.memory as unknown as Uint8Array).buffer, Number(ptr), Number(len));\n    }\n\n    /**\n     * This is a shortcut to easily copy bytes like interplay types to memory. This copies the given buffer and the given buffer\n     * is free to be cleared/freed or used otherwise after this call.\n     * \n     * @param buf to copy as bytes like interplay type to wasm memory\n     * @returns encoded interplay type for this buffer\n     */\n    #encodeBytesLikeType(buf: Uint8Array): bigint {\n        const len = buf.byteLength;\n        // Allocate space in the wasm memory where we can copy these bytes\n        const ptr = this.#wasmAlloc(len);\n        // Copy the buffer data over to the wasm memory\n        new Uint8Array((this.#wasm.memory as unknown as Uint8Array).buffer, ptr, len).set(buf);\n        // Encode the pointer and length\n        return (BigInt.asUintN(32, BigInt(len)) << 32n) | BigInt.asUintN(32, BigInt(ptr));\n    }\n\n    /**\n     * Memory allocation wrapper to simplfiy typing around it. See Zig wasm_allocator for details.\n     * \n     * @param len the number of bytes to allocate\n     * @returns a ptr to the allocated space or -1 as an error\n     */\n    #wasmAlloc(len: number|bigint) {\n        const alloc = this.#wasm.alloc as (len: number) => number;\n\n        return alloc(Number(len) >>> 32);\n    }\n\n    /**\n     * Memory free wrapper to simplify typing around it. See Zig wasm_allocator for details.\n     * \n     * @param ptr pointer of the memory space to free\n     * @param len length of the region to free\n     */\n    #wasmFree(ptr: number|bigint, len: number|bigint) {\n        const free = this.#wasm.free as (ptr: number, len: number) => void;\n\n        console.log('ptr', ptr, 'len', len, 'sp', this.#wasm.stackPointer())\n\n        free(Number(ptr) >>> 32, Number(len) >>> 32)\n    }\n\n    /**\n     * As soon as a call to the WASM function os over or the return has been decoded into a JavaScript value, any allocations\n     * done for those types, on both Zig and JS side, will be freed with this function.\n     * \n     * @param value the interplay type to free the allocated resources for\n     */\n    #freeEncodedInterplayType(value: InterplayType) {\n        // TODO: Currently the base of this function is repeating code of the #decodeInterplayType function and should be reworked.\n\n        // Merge the interplay type to a single u128 value\n        const ipl = BigInt.asUintN(64, value[0]) | (BigInt.asUintN(64, value[1]) << 64n);\n\n        // Extract type and value sections\n        const { type, details } = this.#extractBitSections(ipl, [\n            ['type', 4],\n            ['details', 124]\n        ]);\n\n        // Handle all the different types\n        switch (Number(type)) {\n            case InterplayTypeId.void:\n            case InterplayTypeId.bool:\n            case InterplayTypeId.int:\n            case InterplayTypeId.uint:\n            case InterplayTypeId.float:\n                // These types don't allocate any space and are only stored in the interplay type itself.\n                break;\n            case InterplayTypeId.bytes:\n            case InterplayTypeId.string:\n            case InterplayTypeId.json: {\n                // Extract pointer and length from the details\n                const { ptr, len } = this.#extractBitSections(details, [\n                    ['ptr', 32],\n                    ['len', 32],\n                ]);\n\n                this.#wasmFree(ptr, len);\n                break;\n            }\n            case InterplayTypeId.function: {\n                // Extract pointer and origin of the function\n                const { ptr, origin } = this.#extractBitSections(details, [\n                    ['ptr', 32],\n                    ['origin', 1],\n                ])\n\n                // We only have to do a cleanup on a JavaScript function\n                if(origin === 1n) {\n                    delete this.#functionTable[Number(ptr)];\n                }\n                break;\n            }\n            case InterplayTypeId.array: {\n                // Extract pointer and number of items of the array\n                const { ptr, len } = this.#extractBitSections(details, [\n                    ['ptr', 32],\n                    ['len', 32],\n                ])\n\n                // View as array of u64, the length is twice as long as the number of items because len * 128bit = len * 2 * 64bit\n                const tempBuf = new BigUint64Array((this.#wasm.memory as unknown as Uint8Array).buffer, Number(ptr), Number(len * 2n));\n\n                for(let i = 0; i < len; i++) {\n                    const iplVariable = Array.from(tempBuf.subarray(i * 2, (i + 1) * 2)) as InterplayType;\n                    this.#freeEncodedInterplayType(iplVariable);\n                }\n\n                // Free the array itself (1item = 128 bit = 16 bytes)\n                this.#wasmFree(ptr, len * 16n);\n                break;\n            }\n            default:\n                throw new Error(`Interplay type ${type} is not supported for decoding.`)\n        }\n    }\n}\n\n/**\n * This is the equivalent to the InterplayTypeId in the interplay.zig file.\n */\nexport enum InterplayTypeId {\n    void = 0,\n    bool = 1,\n    int = 2,\n    uint = 3,\n    float = 4,\n    bytes = 5,\n    string = 6,\n    json = 7,\n    function = 8,\n    array = 9\n};"],
  "mappings": "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",
  "names": ["InterplayInstance", "#wasm", "#wasmMemoryDataPtr", "#textDecoder", "#textEncoder", "#functionTable", "wasmUrl", "rawWasm", "resp", "rawModule", "inst", "obj", "arg", "arg2", "message", "#decodeInterplayType", "func", "func2", "args", "args2", "f", "a", "#encodeInterplayType", "#loadWasmObj", "name", "n", "#wrappedCallHandler", "funcName", "wasmFunc", "#wrappedCall", "wasmArgs", "r", "i", "#freeEncodedInterplayType", "wasmReturn", "#extractBitSections", "value", "sections", "bits", "section", "#packBitSections", "#mapValueToInterplayTypeId", "ipl", "type", "details", "rawFloatValue", "tempBuf", "tempBufView", "buf", "#decodeBytesLikeType", "str", "json", "ptr", "origin", "boundF", "len", "decodedArray", "iplVariable", "variable", "iplType", "iplValue", "#encodeBytesLikeType", "key", "bufLen", "#wasmAlloc", "encodedEl", "fullInfo", "alloc", "#wasmFree", "free", "InterplayTypeId"]
}
